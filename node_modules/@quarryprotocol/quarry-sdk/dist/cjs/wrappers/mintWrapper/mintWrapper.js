"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MintWrapper = void 0;
const tslib_1 = require("tslib");
const solana_contrib_1 = require("@saberhq/solana-contrib");
const token_utils_1 = require("@saberhq/token-utils");
const web3_js_1 = require("@solana/web3.js");
const pda_1 = require("./pda");
class MintWrapper {
    constructor(sdk) {
        this.sdk = sdk;
        this.program = sdk.programs.MintWrapper;
    }
    get provider() {
        return this.sdk.provider;
    }
    newWrapper({ hardcap, tokenMint, baseKP = web3_js_1.Keypair.generate(), tokenProgram = token_utils_1.TOKEN_PROGRAM_ID, admin = this.program.provider.wallet.publicKey, payer = this.program.provider.wallet.publicKey, }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const [mintWrapper, nonce] = yield (0, pda_1.findMintWrapperAddress)(baseKP.publicKey, this.program.programId);
            return {
                mintWrapper,
                tx: new solana_contrib_1.TransactionEnvelope(this.provider, [
                    this.program.instruction.newWrapper(nonce, hardcap, {
                        accounts: {
                            base: baseKP.publicKey,
                            mintWrapper,
                            admin,
                            tokenMint,
                            tokenProgram,
                            payer,
                            systemProgram: web3_js_1.SystemProgram.programId,
                        },
                    }),
                ], [baseKP]),
            };
        });
    }
    newWrapperAndMint(_a) {
        var { mintKP = web3_js_1.Keypair.generate(), decimals = 6 } = _a, newWrapperArgs = (0, tslib_1.__rest)(_a, ["mintKP", "decimals"]);
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const provider = this.provider;
            const { mintWrapper, tx: initMintProxyTX } = yield this.newWrapper(Object.assign(Object.assign({}, newWrapperArgs), { tokenMint: mintKP.publicKey }));
            const initMintTX = yield (0, token_utils_1.createInitMintInstructions)({
                provider,
                mintAuthority: mintWrapper,
                freezeAuthority: mintWrapper,
                mintKP,
                decimals,
            });
            return {
                mintWrapper,
                mint: mintKP.publicKey,
                tx: initMintTX.combine(initMintProxyTX),
            };
        });
    }
    /**
     * Fetches info on a Mint Wrapper.
     * @param minter
     * @returns
     */
    fetchMintWrapper(wrapper) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const accountInfo = yield this.program.provider.connection.getAccountInfo(wrapper);
            if (!accountInfo) {
                return null;
            }
            return this.program.coder.accounts.decode("MintWrapper", accountInfo.data);
        });
    }
    /**
     * Fetches info on a minter.
     * @param minter
     * @returns
     */
    fetchMinter(wrapper, authority) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const [minterAddress] = yield (0, pda_1.findMinterAddress)(wrapper, authority, this.program.programId);
            const accountInfo = yield this.program.provider.connection.getAccountInfo(minterAddress);
            if (!accountInfo) {
                return null;
            }
            return this.program.coder.accounts.decode("Minter", accountInfo.data);
        });
    }
    newMinter(wrapper, authority) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const [minter, bump] = yield (0, pda_1.findMinterAddress)(wrapper, authority, this.program.programId);
            return this.provider.newTX([
                this.program.instruction.newMinter(bump, {
                    accounts: {
                        auth: {
                            mintWrapper: wrapper,
                            admin: this.program.provider.wallet.publicKey,
                        },
                        minterAuthority: authority,
                        minter,
                        payer: this.program.provider.wallet.publicKey,
                        systemProgram: web3_js_1.SystemProgram.programId,
                    },
                }),
            ]);
        });
    }
    /**
     * Updates a minter's allowance.
     * @param minter
     * @param allowance
     * @returns
     */
    minterUpdate(wrapper, authority, allowance) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const [minter] = yield (0, pda_1.findMinterAddress)(wrapper, authority, this.program.programId);
            return this.provider.newTX([
                this.program.instruction.minterUpdate(allowance, {
                    accounts: {
                        auth: {
                            mintWrapper: wrapper,
                            admin: this.program.provider.wallet.publicKey,
                        },
                        minter,
                    },
                }),
            ]);
        });
    }
    /**
     * Creates a new Minter with an allowance.
     * @param wrapper
     * @param authority
     * @param allowance
     * @returns
     */
    newMinterWithAllowance(wrapper, authority, allowance) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const newMinter = yield this.newMinter(wrapper, authority);
            const updateAllowance = yield this.minterUpdate(wrapper, authority, allowance);
            return newMinter.combine(updateAllowance);
        });
    }
    transferAdmin(wrapper, nextAdmin) {
        return this.provider.newTX([
            this.program.instruction.transferAdmin({
                accounts: {
                    mintWrapper: wrapper,
                    admin: this.program.provider.wallet.publicKey,
                    nextAdmin,
                },
            }),
        ]);
    }
    acceptAdmin(wrapper) {
        return this.provider.newTX([
            this.program.instruction.acceptAdmin({
                accounts: {
                    mintWrapper: wrapper,
                    pendingAdmin: this.program.provider.wallet.publicKey,
                },
            }),
        ]);
    }
    /**
     * Mints tokens to an address as a Minter on the Mint Wrapper.
     */
    performMintTo({ amount, mintWrapper, minterAuthority = this.provider.wallet.publicKey, destOwner = this.provider.wallet.publicKey, }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const ata = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint: amount.token.mintAccount,
                owner: destOwner,
            });
            const [minter] = yield (0, pda_1.findMinterAddress)(mintWrapper, minterAuthority);
            return this.sdk.provider.newTX([
                ata.instruction,
                this.program.instruction.performMint(amount.toU64(), {
                    accounts: {
                        mintWrapper,
                        minterAuthority,
                        tokenMint: amount.token.mintAccount,
                        destination: ata.address,
                        minter,
                        tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                    },
                }),
            ]);
        });
    }
    /**
     * Performs a mint of tokens to an account.
     * @returns
     */
    performMint({ amount, minter, }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const minterData = minter.accountInfo.data;
            const ata = yield (0, token_utils_1.getOrCreateATA)({
                provider: this.provider,
                mint: amount.token.mintAccount,
                owner: this.provider.wallet.publicKey,
            });
            return this.provider.newTX([
                ata.instruction,
                this.program.instruction.performMint(amount.toU64(), {
                    accounts: {
                        mintWrapper: minterData.mintWrapper,
                        minterAuthority: minterData.minterAuthority,
                        tokenMint: amount.token.mintAccount,
                        destination: ata.address,
                        minter: minter.accountId,
                        tokenProgram: token_utils_1.TOKEN_PROGRAM_ID,
                    },
                }),
            ]);
        });
    }
}
exports.MintWrapper = MintWrapper;
//# sourceMappingURL=mintWrapper.js.map